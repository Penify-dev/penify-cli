import json
import random
import sys
import os
import argparse
from pathlib import Path
import webbrowser
import http.server
import socketserver
import urllib.parse
from threading import Thread
import logging
import pkg_resources

from penify_hook.utils import find_git_parent

from .commit_analyzer import CommitDocGenHook
from .folder_analyzer import FolderAnalyzerGenHook
from .file_analyzer import FileAnalyzerGenHook
from .api_client import APIClient
from .git_analyzer import GitDocGenHook
try:
    from .llm_client import LLMClient
except ImportError:
    # Handle case where litellm is not installed
    LLMClient = None

try:
    from .jira_client import JiraClient
except ImportError:
    # Handle case where jira is not installed
    JiraClient = None

HOOK_FILENAME = "post-commit"
HOOK_TEMPLATE = """#!/bin/sh
# This is a post-commit hook generated by penifycli.

penifycli -t {token} -gf {git_folder_path}
"""
api_url = 'https://production-gateway.snorkell.ai/api'
dashboard_url = "https://dashboard.penify.dev/auth/localhost/login"
# api_url = 'http://localhost:8000/api'

def install_git_hook(location, token):
    """
    Install a post-commit hook in the specified location.
    Args:
        location (str): The path to the Git repository.
        token (str): The token to be used in the hook.
    Raises:
        SystemExit: If the hooks directory does not exist.
    Returns:
        None
    """
    hooks_dir = Path(location) / ".git/hooks"
    hook_path = hooks_dir / HOOK_FILENAME
    
    if not hooks_dir.exists():
        print(f"Error: The hooks directory {hooks_dir} does not exist.")
        sys.exit(1)
    
    hook_content = HOOK_TEMPLATE.format(token=token, git_folder_path=location)
    hook_path.write_text(hook_content)
    hook_path.chmod(0o755)  # Make the hook script executable

    print(f"Post-commit hook installed in {hook_path}")

def uninstall_git_hook(location):
    """
    Uninstalls the post-commit hook from the specified location.
    Parameters:
    - location (str): The path to the directory containing the Git repository.
    Returns:
    None
    """
    hook_path = Path(location) / ".git/hooks" / HOOK_FILENAME
    
    if hook_path.exists():
        hook_path.unlink()
        print(f"Post-commit hook uninstalled from {hook_path}")
    else:
        print(f"No post-commit hook found in {hook_path}")

def generate_doc(token, file_path=None, complete_folder_path=None, git_folder_path=None):
    """
    Generates documentation based on the given parameters.
    Parameters:
    - token (str): The API token for authentication.
    - file_path (str, optional): The path to a specific file to generate documentation for.
    - complete_folder_path (str, optional): The path to a complete folder to generate documentation for.
    - git_folder_path (str, optional): The path to a Git repository folder to generate documentation for.
    """
    
    api_client = APIClient(api_url, token)

    if file_path:
        try:
            analyzer = FileAnalyzerGenHook(file_path, api_client)
            analyzer.run()
        except Exception as e:
            print(f"Error: {e}")
            sys.exit(1)
    elif complete_folder_path:
        try:
            analyzer = FolderAnalyzerGenHook(complete_folder_path, api_client)
            analyzer.run()
        except Exception as e:
            print(f"Error: {e}")
            sys.exit(1)
    else:
        try:
            analyzer = GitDocGenHook(git_folder_path, api_client)
            analyzer.run()
        except Exception as e:
            print(f"Error: {e}")
            sys.exit(1)
    
def commit_code(gf_path: str, token: str, message: str, open_terminal: bool, 
                llm_model=None, llm_api_base=None, llm_api_key=None,
                jira_url=None, jira_user=None, jira_api_token=None):
    """Commit code with optional LLM and JIRA integration.

    This function facilitates the process of committing code by creating an
    API client and optionally initializing a language model (LLM) client and
    a JIRA client if the corresponding parameters are provided. It then uses
    these clients to generate commit documentation and handle interactions
    with JIRA for issue tracking. The function also manages errors that may
    occur during the initialization of the clients or while running the
    commit documentation generation.

    Args:
        gf_path (str): The path to the Git repository or project.
        token (str): The API token for authentication.
        message (str): The commit message to be used.
        open_terminal (bool): Flag indicating whether to open a terminal after the commit.
        llm_model (str?): The model name of the LLM to be used. Defaults to None.
        llm_api_base (str?): The base URL for the LLM API. Defaults to None.
        llm_api_key (str?): The API key for accessing the LLM. Defaults to None.
        jira_url (str?): The URL of the JIRA instance. Defaults to None.
        jira_user (str?): The username for JIRA authentication. Defaults to None.
        jira_api_token (str?): The API token for JIRA authentication. Defaults to None.
    """

    # Create API client
    api_client = APIClient(api_url, token)
    
    # Initialize LLM client if LLM parameters are provided and LLMClient is available
    llm_client = None
    if LLMClient is not None and llm_model:
        try:
            llm_client = LLMClient(
                model=llm_model,
                api_base=llm_api_base,
                api_key=llm_api_key
            )
            print(f"Using LLM model: {llm_model}")
        except Exception as e:
            print(f"Error initializing LLM client: {e}")
            print("Falling back to API for commit summary generation")
    
    # Initialize JIRA client if parameters are provided and JiraClient is available
    jira_client = None
    if JiraClient is not None and jira_url and jira_user and jira_api_token:
        try:
            jira_client = JiraClient(
                jira_url=jira_url,
                jira_user=jira_user,
                jira_api_token=jira_api_token
            )
            if jira_client.is_connected():
                print(f"Connected to JIRA: {jira_url}")
            else:
                print(f"Failed to connect to JIRA: {jira_url}")
                jira_client = None
        except Exception as e:
            print(f"Error initializing JIRA client: {e}")
            jira_client = None
    
    try:
        # Pass the LLM client and JIRA client to CommitDocGenHook
        analyzer = CommitDocGenHook(gf_path, api_client, llm_client, jira_client)
        analyzer.run(message, open_terminal)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)

def save_credentials(api_key):
    """
    Save the token and API keys in the .penify file in the user's home directory.
    """
    home_dir = Path.home()
    penify_file = home_dir / '.penify'

    credentials = {
        'api_keys': api_key
    }

    try:
        with open(penify_file, 'w') as f:
            json.dump(credentials, f)
    except Exception as e:
        print(f"Error saving credentials: {str(e)}")

def save_llm_config(model, api_base, api_key):
    """Save LLM configuration settings in the .penify file in the user's home
    directory.

    This function creates or updates a configuration file named '.penify'
    located in the user's home directory. It stores the provided model, API
    base URL, and API key in a structured format. If the configuration file
    already exists, it attempts to read the existing settings and update
    them with the new values. If any error occurs during reading or writing
    the file, an error message is printed to the console.

    Args:
        model (str): The name of the model to be saved in the configuration.
        api_base (str): The base URL for the API to be saved in the configuration.
        api_key (str): The API key to be saved in the configuration.
    """
    home_dir = Path.home()
    penify_file = home_dir / '.penify'
    
    config = {}
    if penify_file.exists():
        try:
            with open(penify_file, 'r') as f:
                config = json.load(f)
        except json.JSONDecodeError:
            pass
    
    # Update or add LLM configuration
    config['llm'] = {
        'model': model,
        'api_base': api_base,
        'api_key': api_key
    }
    
    try:
        with open(penify_file, 'w') as f:
            json.dump(config, f)
        print(f"LLM configuration saved to {penify_file}")
    except Exception as e:
        print(f"Error saving LLM configuration: {str(e)}")

def save_jira_config(url, username, api_token):
    """Save JIRA configuration settings in the .penify file in the user's home
    directory.

    This function creates or updates a configuration file named '.penify'
    located in the user's home directory. It stores the provided JIRA
    configuration settings, including the URL, username, and API token. If
    the configuration file already exists, it attempts to read the existing
    settings and update them with the new values. In case of any errors
    during file operations, an error message is printed to the console.

    Args:
        url (str): The URL of the JIRA instance.
        username (str): The username for JIRA authentication.
        api_token (str): The API token for JIRA authentication.
    """
    home_dir = Path.home()
    penify_file = home_dir / '.penify'
    
    config = {}
    if penify_file.exists():
        try:
            with open(penify_file, 'r') as f:
                config = json.load(f)
        except json.JSONDecodeError:
            pass
    
    # Update or add JIRA configuration
    config['jira'] = {
        'url': url,
        'username': username,
        'api_token': api_token
    }
    
    try:
        with open(penify_file, 'w') as f:
            json.dump(config, f)
        print(f"JIRA configuration saved to {penify_file}")
    except Exception as e:
        print(f"Error saving JIRA configuration: {str(e)}")

def get_llm_config():
    """Retrieve the LLM configuration from the .penify file.

    This function checks for the existence of a configuration file named
    '.penify' in the user's home directory. If the file exists, it attempts
    to read and parse the JSON content. The function specifically looks for
    the 'llm' key in the parsed configuration and returns its value as a
    dictionary. If the file does not exist or if there is an error while
    reading or parsing the file, an empty dictionary is returned.

    Returns:
        dict: The LLM configuration as a dictionary, or an empty dictionary
        if the configuration file does not exist or cannot be read.
    """
    config_file = Path.home() / '.penify'
    if config_file.exists():
        try:
            with open(config_file, 'r') as f:
                config = json.load(f)
                return config.get('llm', {})
        except json.JSONDecodeError:
            print("Error reading .penify config file. File may be corrupted.")
        except Exception as e:
            print(f"Error reading .penify config file: {str(e)}")
    
    return {}

def get_jira_config():
    """Retrieve JIRA configuration from the .penify file.

    This function checks for the existence of the .penify configuration file
    in the user's home directory. If the file exists, it attempts to read
    and parse the JSON content. The function specifically looks for the
    'jira' key in the configuration and returns its associated value. If the
    file does not exist or cannot be read, an empty dictionary is returned.

    Returns:
        dict: A dictionary containing the JIRA configuration if found, otherwise an
            empty dictionary.
    """
    config_file = Path.home() / '.penify'
    if config_file.exists():
        try:
            with open(config_file, 'r') as f:
                config = json.load(f)
                return config.get('jira', {})
        except json.JSONDecodeError:
            print("Error reading .penify config file. File may be corrupted.")
        except Exception as e:
            print(f"Error reading .penify config file: {str(e)}")
    
    return {}

def login():
    """
    Open the login page in a web browser and listen for the redirect URL to capture the token.
    """
    
    # dashboard_url = "http://localhost:8000/auth/localhost/login"
    redirect_port = random.randint(30000, 50000)
    redirect_url = f"http://localhost:{redirect_port}/callback"
    
    full_login_url = f"{dashboard_url}?redirectUri={urllib.parse.quote(redirect_url)}"
    
    print(f"Opening login page in your default web browser: {full_login_url}")
    webbrowser.open(full_login_url)
    
    class TokenHandler(http.server.SimpleHTTPRequestHandler):
        def do_GET(self):
            query = urllib.parse.urlparse(self.path).query
            query_components = urllib.parse.parse_qs(query)
            token = query_components.get("token", [None])[0]
            
            if token:
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                response = """
                <html>
                <head>
                    <script>
                        setTimeout(function() {
                            window.location.href = 'https://dashboard.penify.dev';
                        }, 5000);
                    </script>
                </head>
                <body>
                    <h1>Login Successful!</h1>
                    <p>You will be redirected to the Penify dashboard in 5 seconds. You can also close this window and return to the CLI.</p>
                </body>
                </html>
                """
                self.wfile.write(response.encode())
                
                print(f"\nLogin successful! Fetching API keys...")
                api_key = APIClient(api_url, None, token).get_api_key()
                if api_key:
                    save_credentials(api_key)
                    print("API keys fetched and saved successfully.")
                    print("You'll be redirected to the Penify dashboard. You can continue using the CLI.")
                else:
                    print("Failed to fetch API keys.")
            else:
                self.send_response(400)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                response = """
                <html>
                <body>
                <h1>Login Failed</h1>
                <p>Please try again.</p>
                </body>
                </html>
                """
                self.wfile.write(response.encode())
                print("\nLogin failed. Please try again.")
            
            # Schedule the server shutdown
            thread = Thread(target=self.server.shutdown)
            thread.daemon = True
            thread.start()

        def log_message(self, format, *args):
            # Suppress log messages
            return
    
    with socketserver.TCPServer(("", redirect_port), TokenHandler) as httpd:
        print(f"Listening on port {redirect_port} for the redirect...")
        httpd.serve_forever()
    
    print("Login process completed. You can now use other commands with your API token.")

def config_llm_web():
    """Open a web browser interface for configuring LLM settings.

    This function starts a simple HTTP server that serves a configuration
    page for LLM (Large Language Model) settings. It generates a random port
    number for the server and opens the configuration page in the user's
    default web browser. The server handles GET requests to serve the
    configuration HTML and POST requests to save the configuration data.
    Upon saving, it responds with a success message or an error message if
    the saving process fails.
    """
    redirect_port = random.randint(30000, 50000)
    server_url = f"http://localhost:{redirect_port}"
    
    print(f"Starting configuration server on {server_url}")
    
    class ConfigHandler(http.server.SimpleHTTPRequestHandler):
        def do_GET(self):
            """Handle GET requests for the web server.

            This method processes incoming GET requests. If the request path is the
            root ("/"), it responds with a 200 status code and serves an HTML
            template file. If the request path is anything else, it responds with a
            404 status code indicating that the requested resource was not found.
            """

            if self.path == "/":
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                
                # Read the template HTML file
                template_path = pkg_resources.resource_filename(
                    "penify_hook", "templates/llm_config.html"
                )
                
                with open(template_path, 'r') as f:
                    content = f.read()
                
                self.wfile.write(content.encode())
            else:
                self.send_response(404)
                self.send_header("Content-type", "text/plain")
                self.end_headers()
                self.wfile.write(b"Not Found")

        def do_POST(self):
            """Handle POST requests to save LLM configuration.

            This method processes incoming POST requests to the "/save" endpoint. It
            reads the request body to extract the model, API base, and API key from
            the JSON payload. If the configuration is saved successfully, it sends a
            success response and initiates a server shutdown in a separate thread.
            If an error occurs during the saving process, it sends an error
            response. If the request path is not recognized, it returns a 404 Not
            Found response.
            """

            if self.path == "/save":
                content_length = int(self.headers['Content-Length'])
                post_data = self.rfile.read(content_length)
                data = json.loads(post_data.decode())
                
                model = data.get('model')
                api_base = data.get('api_base')
                api_key = data.get('api_key')
                
                try:
                    save_llm_config(model, api_base, api_key)
                    
                    self.send_response(200)
                    self.send_header("Content-type", "application/json")
                    self.end_headers()
                    response = {
                        "success": True, 
                        "message": f"LLM configuration saved successfully. Using model: {model}"
                    }
                    self.wfile.write(json.dumps(response).encode())
                    
                    # Schedule the server shutdown
                    thread = Thread(target=self.server.shutdown)
                    thread.daemon = True
                    thread.start()
                    
                except Exception as e:
                    self.send_response(500)
                    self.send_header("Content-type", "application/json")
                    self.end_headers()
                    response = {"success": False, "message": f"Error saving configuration: {str(e)}"}
                    self.wfile.write(json.dumps(response).encode())
            else:
                self.send_response(404)
                self.send_header("Content-type", "application/json")
                self.end_headers()
                self.wfile.write(json.dumps({"success": False, "message": "Not Found"}).encode())
        
        def log_message(self, format, *args):
            # Suppress log messages
            return

    with socketserver.TCPServer(("", redirect_port), ConfigHandler) as httpd:
        print(f"Opening configuration page in your browser...")
        webbrowser.open(server_url)
        print(f"Waiting for configuration to be submitted...")
        httpd.serve_forever()
    
    print("Configuration completed.")

def config_jira_web():
    """Open a web browser interface for configuring JIRA settings.

    This function sets up a simple HTTP server that serves a configuration
    page for JIRA settings. It generates a random port for the server and
    opens the configuration page in the user's default web browser. The
    server handles both GET and POST requests. The GET request serves an
    HTML template for the configuration, while the POST request processes
    the submitted configuration data, saves it, and optionally verifies the
    connection to JIRA.
    """
    redirect_port = random.randint(30000, 50000)
    server_url = f"http://localhost:{redirect_port}"
    
    print(f"Starting configuration server on {server_url}")
    
    class ConfigHandler(http.server.SimpleHTTPRequestHandler):
        def do_GET(self):
            """Handle GET requests for the web server.

            This method processes incoming GET requests. If the request path is the
            root ("/"), it responds with a 200 status code and serves an HTML
            template file. If the request path is anything else, it responds with a
            404 status code indicating that the requested resource was not found.
            """

            if self.path == "/":
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                
                # Read the template HTML file
                template_path = pkg_resources.resource_filename(
                    "penify_hook", "templates/jira_config.html"
                )
                
                with open(template_path, 'r') as f:
                    content = f.read()
                
                self.wfile.write(content.encode())
            else:
                self.send_response(404)
                self.send_header("Content-type", "text/plain")
                self.end_headers()
                self.wfile.write(b"Not Found")

        def do_POST(self):
            """Handle POST requests to save JIRA configuration.

            This method processes incoming POST requests to the "/save" endpoint. It
            reads the request body to extract JIRA configuration details such as the
            URL, username, and API token. If requested, it verifies the connection
            to the JIRA server using the provided credentials. Upon successful
            saving of the configuration, it sends a response indicating success or
            failure, along with any verification messages. If an error occurs during
            the process, it returns an appropriate error message.
            """

            if self.path == "/save":
                content_length = int(self.headers['Content-Length'])
                post_data = self.rfile.read(content_length)
                data = json.loads(post_data.decode())
                
                url = data.get('url')
                username = data.get('username')
                api_token = data.get('api_token')
                verify = data.get('verify', False)
                
                try:
                    # Save the configuration
                    save_jira_config(url, username, api_token)
                    
                    # Verify the connection if requested
                    verify_message = ""
                    if verify and JiraClient is not None:
                        jira_client = JiraClient(
                            jira_url=url,
                            jira_user=username,
                            jira_api_token=api_token
                        )
                        if jira_client.is_connected():
                            verify_message = " Connection to JIRA verified successfully!"
                        else:
                            verify_message = " Warning: Could not connect to JIRA with these credentials."
                    
                    self.send_response(200)
                    self.send_header("Content-type", "application/json")
                    self.end_headers()
                    response = {
                        "success": True, 
                        "message": f"JIRA configuration saved successfully.{verify_message}"
                    }
                    self.wfile.write(json.dumps(response).encode())
                    
                    # Schedule the server shutdown
                    thread = Thread(target=self.server.shutdown)
                    thread.daemon = True
                    thread.start()
                    
                except Exception as e:
                    self.send_response(500)
                    self.send_header("Content-type", "application/json")
                    self.end_headers()
                    response = {"success": False, "message": f"Error saving configuration: {str(e)}"}
                    self.wfile.write(json.dumps(response).encode())
            else:
                self.send_response(404)
                self.send_header("Content-type", "application/json")
                self.end_headers()
                self.wfile.write(json.dumps({"success": False, "message": "Not Found"}).encode())
        
        def log_message(self, format, *args):
            # Suppress log messages
            return

    with socketserver.TCPServer(("", redirect_port), ConfigHandler) as httpd:
        print(f"Opening configuration page in your browser...")
        webbrowser.open(server_url)
        print(f"Waiting for configuration to be submitted...")
        httpd.serve_forever()
    
    print("Configuration completed.")

def get_token(passed_token):
    """
    Get the token based on priority:
    1. Passed parameter
    2. Environment variable
    3. Config file
    """
    if passed_token:
        return passed_token
    
    env_token = os.getenv('PENIFY_API_TOKEN')
    if env_token:
        return env_token
    
    config_file = Path.home() / '.penify'
    if config_file.exists():
        try:
            with open(config_file, 'r') as f:
                config = json.load(f)
                return config.get('api_keys')
        except json.JSONDecodeError:
            print("Error reading .penify config file. File may be corrupted.")
        except Exception as e:
            print(f"Error reading .penify config file: {str(e)}")
    
    return None

def main():
    """Main entry point for the Penify CLI tool.

    This function sets up the command-line interface (CLI) for managing Git
    hooks and generating documentation. It utilizes the argparse library to
    define various subcommands, including installing and uninstalling Git
    hooks, generating documentation, committing changes, and logging in to
    obtain an API token. The function also handles the retrieval of the API
    token based on user input or environment variables and executes the
    appropriate subcommand based on user selection.  It provides a
    structured way to interact with the Penify tool, allowing users to
    configure settings for LLM (Language Model) and JIRA integration, as
    well as manage Git hooks effectively. Each subcommand is designed to
    facilitate specific tasks, ensuring that users can easily navigate and
    utilize the functionalities offered by the Penify CLI.
    """
    # Configure logging
    logging.basicConfig(level=logging.WARNING, 
                       format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    parser = argparse.ArgumentParser(description="Penify CLI tool for managing Git hooks and generating documentation.")
    
    parser.add_argument("-t", "--token", help="API token for authentication. If not provided, will check PENIFY_API_TOKEN environment variable, then .penify config file.")

    subparsers = parser.add_subparsers(title="subcommands", dest="subcommand")

    # Subcommand: install-hook
    install_parser = subparsers.add_parser("install-hook", help="Install the Git post-commit hook.")
    install_parser.add_argument("-l", "--location", required=True, help="Location in which to install the Git hook.")

    # Subcommand: uninstall-hook
    uninstall_parser = subparsers.add_parser("uninstall-hook", help="Uninstall the Git post-commit hook.")
    uninstall_parser.add_argument("-l", "--location", required=True, help="Location from which to uninstall the Git hook.")

    # Subcommand: doc-gen
    doc_gen_parser = subparsers.add_parser("doc-gen", help="Generate documentation for specified files or folders.")
    doc_gen_parser.add_argument("-fl", "--file_path", help="Path of the file to generate documentation.")
    doc_gen_parser.add_argument("-cf", "--complete_folder_path", help="Generate documentation for the entire folder.")
    doc_gen_parser.add_argument("-gf", "--git_folder_path", help="Path to the folder, with git, to scan for modified files. Defaults to the current folder.", default=os.getcwd())

    # Subcommand: commit - update with LLM and JIRA options
    commit_parser = subparsers.add_parser("commit", help="Commit with a message.")
    commit_parser.add_argument("-gf", "--git_folder_path", help="Path to the folder, with git, to scan for modified files. Defaults to the current folder.", default=os.getcwd())
    commit_parser.add_argument("-m", "--message", required=False, help="Commit message.", default="N/A")
    commit_parser.add_argument("-e", "--terminal", required=False, help="Open edit terminal", default="False")
    # Add LLM options
    commit_parser.add_argument("--llm", "--llm-model", dest="llm_model", help="LLM model to use for commit message generation (e.g., ollama/llama2, gpt-3.5-turbo)")
    commit_parser.add_argument("--llm-api-base", help="API base URL for the LLM service (e.g., http://localhost:11434 for Ollama)")
    commit_parser.add_argument("--llm-api-key", help="API key for the LLM service")
    # Add JIRA options
    commit_parser.add_argument("--jira-url", help="JIRA base URL (e.g., https://your-domain.atlassian.net)")
    commit_parser.add_argument("--jira-user", help="JIRA username or email")
    commit_parser.add_argument("--jira-api-token", help="JIRA API token")

    # Add a new subcommand: config-llm
    llm_config_parser = subparsers.add_parser("config-llm", help="Configure LLM settings for commit message generation")
    llm_config_parser.add_argument("--model", required=True, help="LLM model to use (e.g., ollama/llama2, gpt-3.5-turbo)")
    llm_config_parser.add_argument("--api-base", help="API base URL for the LLM service (e.g., http://localhost:11434 for Ollama)")
    llm_config_parser.add_argument("--api-key", help="API key for the LLM service")

    # Add a new subcommand: config-llm-web
    llm_config_web_parser = subparsers.add_parser("config-llm-web", help="Configure LLM settings through a web interface")

    # Add a new subcommand: config-jira
    jira_config_parser = subparsers.add_parser("config-jira", help="Configure JIRA settings for commit integration")
    jira_config_parser.add_argument("--url", required=True, help="JIRA base URL (e.g., https://your-domain.atlassian.net)")
    jira_config_parser.add_argument("--username", required=True, help="JIRA username or email")
    jira_config_parser.add_argument("--api-token", required=True, help="JIRA API token")
    jira_config_parser.add_argument("--verify", action="store_true", help="Verify JIRA connection after configuration")

    # Add a new subcommand: config-jira-web
    jira_config_web_parser = subparsers.add_parser("config-jira-web", help="Configure JIRA settings through a web interface")

    # Subcommand: login
    login_parser = subparsers.add_parser("login", help="Log in to Penify and obtain an API token.")

    args = parser.parse_args()

    # Get the token based on priority
    token = get_token(args.token)

    if args.subcommand == "install-hook":
        if not token:
            print("Error: API token is required. Please provide it using -t option, PENIFY_API_TOKEN environment variable, or log in first.")
            sys.exit(1)
        install_git_hook(args.location, token)
    elif args.subcommand == "uninstall-hook":
        uninstall_git_hook(args.location)
    elif args.subcommand == "doc-gen":
        if not token:
            print("Error: API token is required. Please provide it using -t option, PENIFY_API_TOKEN environment variable, or log in first.")
            sys.exit(1)
        generate_doc(token, args.file_path, args.complete_folder_path, args.git_folder_path)
    elif args.subcommand == "commit":
        if not token:
            print("Error: API token is required. Please provide it using -t option, PENIFY_API_TOKEN environment variable, or log in first.")
            sys.exit(1)
        
        open_terminal = args.terminal.lower() == "true"
        
        # Get LLM configuration - first from command line args, then from config file
        llm_model = args.llm_model
        llm_api_base = args.llm_api_base
        llm_api_key = args.llm_api_key
        
        if not llm_model:
            # Try to get from config
            llm_config = get_llm_config()
            llm_model = llm_config.get('model')
            llm_api_base = llm_config.get('api_base') if not llm_api_base else llm_api_base
            llm_api_key = llm_config.get('api_key') if not llm_api_key else llm_api_key
        
        # Get JIRA configuration - first from command line args, then from config file
        jira_url = args.jira_url
        jira_user = args.jira_user
        jira_api_token = args.jira_api_token
        
        if not jira_url or not jira_user or not jira_api_token:
            # Try to get from config
            jira_config = get_jira_config()
            jira_url = jira_url or jira_config.get('url')
            jira_user = jira_user or jira_config.get('username')
            jira_api_token = jira_api_token or jira_config.get('api_token')
        
        commit_code(args.git_folder_path, token, args.message, open_terminal,
                   llm_model, llm_api_base, llm_api_key,
                   jira_url, jira_user, jira_api_token)
    
    elif args.subcommand == "config-llm":
        # Save LLM configuration
        save_llm_config(args.model, args.api_base, args.api_key)
        print(f"LLM configuration set: Model={args.model}, API Base={args.api_base or 'default'}")
    
    elif args.subcommand == "config-llm-web":
        # Open web interface for LLM configuration
        config_llm_web()
    
    elif args.subcommand == "config-jira":
        # Save JIRA configuration
        save_jira_config(args.url, args.username, args.api_token)
        print(f"JIRA configuration set: URL={args.url}, Username={args.username}")
        
        # Verify connection if requested
        if args.verify:
            if JiraClient:
                jira_client = JiraClient(
                    jira_url=args.url,
                    jira_user=args.username,
                    jira_api_token=args.api_token
                )
                if jira_client.is_connected():
                    print("JIRA connection verified successfully!")
                else:
                    print("Failed to connect to JIRA. Please check your credentials.")
            else:
                print("JIRA package not installed. Cannot verify connection.")
    
    elif args.subcommand == "config-jira-web":
        # Open web interface for JIRA configuration
        config_jira_web()
    
    elif args.subcommand == "login":
        login()
    else:
        parser.print_help()
        sys.exit(1)

if __name__ == "__main__":
    main()
