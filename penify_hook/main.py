import json
import random
import sys
import os
import argparse
from pathlib import Path
import webbrowser
import http.server
import socketserver
import urllib.parse
from threading import Thread
import logging

from penify_hook.utils import find_git_parent

from .commit_analyzer import CommitDocGenHook
from .folder_analyzer import FolderAnalyzerGenHook
from .file_analyzer import FileAnalyzerGenHook
from .api_client import APIClient
from .git_analyzer import GitDocGenHook
try:
    from .llm_client import LLMClient
except ImportError:
    # Handle case where litellm is not installed
    LLMClient = None

try:
    from .jira_client import JiraClient
except ImportError:
    # Handle case where jira is not installed
    JiraClient = None

HOOK_FILENAME = "post-commit"
HOOK_TEMPLATE = """#!/bin/sh
# This is a post-commit hook generated by penify-cli.

penify-cli -t {token} -gf {git_folder_path}
"""
api_url = 'https://production-gateway.snorkell.ai/api'
dashboard_url = "https://dashboard.penify.dev/auth/localhost/login"
# api_url = 'http://localhost:8000/api'

def install_git_hook(location, token):
    """
    Install a post-commit hook in the specified location.
    Args:
        location (str): The path to the Git repository.
        token (str): The token to be used in the hook.
    Raises:
        SystemExit: If the hooks directory does not exist.
    Returns:
        None
    """
    hooks_dir = Path(location) / ".git/hooks"
    hook_path = hooks_dir / HOOK_FILENAME
    
    if not hooks_dir.exists():
        print(f"Error: The hooks directory {hooks_dir} does not exist.")
        sys.exit(1)
    
    hook_content = HOOK_TEMPLATE.format(token=token, git_folder_path=location)
    hook_path.write_text(hook_content)
    hook_path.chmod(0o755)  # Make the hook script executable

    print(f"Post-commit hook installed in {hook_path}")

def uninstall_git_hook(location):
    """
    Uninstalls the post-commit hook from the specified location.
    Parameters:
    - location (str): The path to the directory containing the Git repository.
    Returns:
    None
    """
    hook_path = Path(location) / ".git/hooks" / HOOK_FILENAME
    
    if hook_path.exists():
        hook_path.unlink()
        print(f"Post-commit hook uninstalled from {hook_path}")
    else:
        print(f"No post-commit hook found in {hook_path}")

def generate_doc(token, file_path=None, complete_folder_path=None, git_folder_path=None):
    """
    Generates documentation based on the given parameters.
    Parameters:
    - token (str): The API token for authentication.
    - file_path (str, optional): The path to a specific file to generate documentation for.
    - complete_folder_path (str, optional): The path to a complete folder to generate documentation for.
    - git_folder_path (str, optional): The path to a Git repository folder to generate documentation for.
    """
    
    api_client = APIClient(api_url, token)

    if file_path:
        try:
            analyzer = FileAnalyzerGenHook(file_path, api_client)
            analyzer.run()
        except Exception as e:
            print(f"Error: {e}")
            sys.exit(1)
    elif complete_folder_path:
        try:
            analyzer = FolderAnalyzerGenHook(complete_folder_path, api_client)
            analyzer.run()
        except Exception as e:
            print(f"Error: {e}")
            sys.exit(1)
    else:
        try:
            analyzer = GitDocGenHook(git_folder_path, api_client)
            analyzer.run()
        except Exception as e:
            print(f"Error: {e}")
            sys.exit(1)
    
def commit_code(gf_path: str, token: str, message: str, open_terminal: bool, 
                llm_model=None, llm_api_base=None, llm_api_key=None,
                jira_url=None, jira_user=None, jira_api_token=None):
    # Create API client
    api_client = APIClient(api_url, token)
    
    # Initialize LLM client if LLM parameters are provided and LLMClient is available
    llm_client = None
    if LLMClient is not None and llm_model:
        try:
            llm_client = LLMClient(
                model=llm_model,
                api_base=llm_api_base,
                api_key=llm_api_key
            )
            print(f"Using LLM model: {llm_model}")
        except Exception as e:
            print(f"Error initializing LLM client: {e}")
            print("Falling back to API for commit summary generation")
    
    # Initialize JIRA client if parameters are provided and JiraClient is available
    jira_client = None
    if JiraClient is not None and jira_url and jira_user and jira_api_token:
        try:
            jira_client = JiraClient(
                jira_url=jira_url,
                jira_user=jira_user,
                jira_api_token=jira_api_token
            )
            if jira_client.is_connected():
                print(f"Connected to JIRA: {jira_url}")
            else:
                print(f"Failed to connect to JIRA: {jira_url}")
                jira_client = None
        except Exception as e:
            print(f"Error initializing JIRA client: {e}")
            jira_client = None
    
    try:
        # Pass the LLM client and JIRA client to CommitDocGenHook
        analyzer = CommitDocGenHook(gf_path, api_client, llm_client, jira_client)
        analyzer.run(message, open_terminal)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)

def save_credentials(api_key):
    """
    Save the token and API keys in the .penify file in the user's home directory.
    """
    home_dir = Path.home()
    penify_file = home_dir / '.penify'

    credentials = {
        'api_keys': api_key
    }

    try:
        with open(penify_file, 'w') as f:
            json.dump(credentials, f)
    except Exception as e:
        print(f"Error saving credentials: {str(e)}")

def save_llm_config(model, api_base, api_key):
    """
    Save LLM configuration settings in the .penify file in the user's home directory.
    """
    home_dir = Path.home()
    penify_file = home_dir / '.penify'
    
    config = {}
    if penify_file.exists():
        try:
            with open(penify_file, 'r') as f:
                config = json.load(f)
        except json.JSONDecodeError:
            pass
    
    # Update or add LLM configuration
    config['llm'] = {
        'model': model,
        'api_base': api_base,
        'api_key': api_key
    }
    
    try:
        with open(penify_file, 'w') as f:
            json.dump(config, f)
        print(f"LLM configuration saved to {penify_file}")
    except Exception as e:
        print(f"Error saving LLM configuration: {str(e)}")

def save_jira_config(url, username, api_token):
    """
    Save JIRA configuration settings in the .penify file in the user's home directory.
    """
    home_dir = Path.home()
    penify_file = home_dir / '.penify'
    
    config = {}
    if penify_file.exists():
        try:
            with open(penify_file, 'r') as f:
                config = json.load(f)
        except json.JSONDecodeError:
            pass
    
    # Update or add JIRA configuration
    config['jira'] = {
        'url': url,
        'username': username,
        'api_token': api_token
    }
    
    try:
        with open(penify_file, 'w') as f:
            json.dump(config, f)
        print(f"JIRA configuration saved to {penify_file}")
    except Exception as e:
        print(f"Error saving JIRA configuration: {str(e)}")

def get_llm_config():
    """
    Get LLM configuration from the .penify file.
    """
    config_file = Path.home() / '.penify'
    if config_file.exists():
        try:
            with open(config_file, 'r') as f:
                config = json.load(f)
                return config.get('llm', {})
        except json.JSONDecodeError:
            print("Error reading .penify config file. File may be corrupted.")
        except Exception as e:
            print(f"Error reading .penify config file: {str(e)}")
    
    return {}

def get_jira_config():
    """
    Get JIRA configuration from the .penify file.
    """
    config_file = Path.home() / '.penify'
    if config_file.exists():
        try:
            with open(config_file, 'r') as f:
                config = json.load(f)
                return config.get('jira', {})
        except json.JSONDecodeError:
            print("Error reading .penify config file. File may be corrupted.")
        except Exception as e:
            print(f"Error reading .penify config file: {str(e)}")
    
    return {}

def login():
    """
    Open the login page in a web browser and listen for the redirect URL to capture the token.
    """
    
    # dashboard_url = "http://localhost:8000/auth/localhost/login"
    redirect_port = random.randint(30000, 50000)
    redirect_url = f"http://localhost:{redirect_port}/callback"
    
    full_login_url = f"{dashboard_url}?redirectUri={urllib.parse.quote(redirect_url)}"
    
    print(f"Opening login page in your default web browser: {full_login_url}")
    webbrowser.open(full_login_url)
    
    class TokenHandler(http.server.SimpleHTTPRequestHandler):
        def do_GET(self):
            query = urllib.parse.urlparse(self.path).query
            query_components = urllib.parse.parse_qs(query)
            token = query_components.get("token", [None])[0]
            
            if token:
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                response = """
                <html>
                <head>
                    <script>
                        setTimeout(function() {
                            window.location.href = 'https://dashboard.penify.dev';
                        }, 5000);
                    </script>
                </head>
                <body>
                    <h1>Login Successful!</h1>
                    <p>You will be redirected to the Penify dashboard in 5 seconds. You can also close this window and return to the CLI.</p>
                </body>
                </html>
                """
                self.wfile.write(response.encode())
                
                print(f"\nLogin successful! Fetching API keys...")
                api_key = APIClient(api_url, None, token).get_api_key()
                if api_key:
                    save_credentials(api_key)
                    print("API keys fetched and saved successfully.")
                    print("You'll be redirected to the Penify dashboard. You can continue using the CLI.")
                else:
                    print("Failed to fetch API keys.")
            else:
                self.send_response(400)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                response = """
                <html>
                <body>
                <h1>Login Failed</h1>
                <p>Please try again.</p>
                </body>
                </html>
                """
                self.wfile.write(response.encode())
                print("\nLogin failed. Please try again.")
            
            # Schedule the server shutdown
            thread = Thread(target=self.server.shutdown)
            thread.daemon = True
            thread.start()

        def log_message(self, format, *args):
            # Suppress log messages
            return
    
    with socketserver.TCPServer(("", redirect_port), TokenHandler) as httpd:
        print(f"Listening on port {redirect_port} for the redirect...")
        httpd.serve_forever()
    
    print("Login process completed. You can now use other commands with your API token.")


def get_token(passed_token):
    """
    Get the token based on priority:
    1. Passed parameter
    2. Environment variable
    3. Config file
    """
    if passed_token:
        return passed_token
    
    env_token = os.getenv('PENIFY_API_TOKEN')
    if env_token:
        return env_token
    
    config_file = Path.home() / '.penify'
    if config_file.exists():
        try:
            with open(config_file, 'r') as f:
                config = json.load(f)
                return config.get('api_keys')
        except json.JSONDecodeError:
            print("Error reading .penify config file. File may be corrupted.")
        except Exception as e:
            print(f"Error reading .penify config file: {str(e)}")
    
    return None

def main():
    """Main entry point for the Penify CLI tool.

    This function sets up the command-line interface (CLI) for managing Git
    hooks and generating documentation. It utilizes the argparse library to
    define various subcommands, including installing and uninstalling Git
    hooks, generating documentation, committing changes, and logging in to
    obtain an API token. The function also handles the retrieval of the API
    token based on user input or environment variables and executes the
    appropriate subcommand based on user selection.
    """
    # Configure logging
    logging.basicConfig(level=logging.WARNING, 
                       format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    parser = argparse.ArgumentParser(description="Penify CLI tool for managing Git hooks and generating documentation.")
    
    parser.add_argument("-t", "--token", help="API token for authentication. If not provided, will check PENIFY_API_TOKEN environment variable, then .penify config file.")

    subparsers = parser.add_subparsers(title="subcommands", dest="subcommand")

    # Subcommand: install-hook
    install_parser = subparsers.add_parser("install-hook", help="Install the Git post-commit hook.")
    install_parser.add_argument("-l", "--location", required=True, help="Location in which to install the Git hook.")

    # Subcommand: uninstall-hook
    uninstall_parser = subparsers.add_parser("uninstall-hook", help="Uninstall the Git post-commit hook.")
    uninstall_parser.add_argument("-l", "--location", required=True, help="Location from which to uninstall the Git hook.")

    # Subcommand: doc-gen
    doc_gen_parser = subparsers.add_parser("doc-gen", help="Generate documentation for specified files or folders.")
    doc_gen_parser.add_argument("-fl", "--file_path", help="Path of the file to generate documentation.")
    doc_gen_parser.add_argument("-cf", "--complete_folder_path", help="Generate documentation for the entire folder.")
    doc_gen_parser.add_argument("-gf", "--git_folder_path", help="Path to the folder, with git, to scan for modified files. Defaults to the current folder.", default=os.getcwd())

    # Subcommand: commit - update with LLM and JIRA options
    commit_parser = subparsers.add_parser("commit", help="Commit with a message.")
    commit_parser.add_argument("-gf", "--git_folder_path", help="Path to the folder, with git, to scan for modified files. Defaults to the current folder.", default=os.getcwd())
    commit_parser.add_argument("-m", "--message", required=False, help="Commit message.", default="N/A")
    commit_parser.add_argument("-e", "--terminal", required=False, help="Open edit terminal", default="False")
    # Add LLM options
    commit_parser.add_argument("--llm", "--llm-model", dest="llm_model", help="LLM model to use for commit message generation (e.g., ollama/llama2, gpt-3.5-turbo)")
    commit_parser.add_argument("--llm-api-base", help="API base URL for the LLM service (e.g., http://localhost:11434 for Ollama)")
    commit_parser.add_argument("--llm-api-key", help="API key for the LLM service")
    # Add JIRA options
    commit_parser.add_argument("--jira-url", help="JIRA base URL (e.g., https://your-domain.atlassian.net)")
    commit_parser.add_argument("--jira-user", help="JIRA username or email")
    commit_parser.add_argument("--jira-api-token", help="JIRA API token")

    # Add a new subcommand: config-llm
    llm_config_parser = subparsers.add_parser("config-llm", help="Configure LLM settings for commit message generation")
    llm_config_parser.add_argument("--model", required=True, help="LLM model to use (e.g., ollama/llama2, gpt-3.5-turbo)")
    llm_config_parser.add_argument("--api-base", help="API base URL for the LLM service (e.g., http://localhost:11434 for Ollama)")
    llm_config_parser.add_argument("--api-key", help="API key for the LLM service")

    # Add a new subcommand: config-jira
    jira_config_parser = subparsers.add_parser("config-jira", help="Configure JIRA settings for commit integration")
    jira_config_parser.add_argument("--url", required=True, help="JIRA base URL (e.g., https://your-domain.atlassian.net)")
    jira_config_parser.add_argument("--username", required=True, help="JIRA username or email")
    jira_config_parser.add_argument("--api-token", required=True, help="JIRA API token")
    jira_config_parser.add_argument("--verify", action="store_true", help="Verify JIRA connection after configuration")

    # Subcommand: login
    login_parser = subparsers.add_parser("login", help="Log in to Penify and obtain an API token.")

    args = parser.parse_args()

    # Get the token based on priority
    token = get_token(args.token)

    if args.subcommand == "install-hook":
        if not token:
            print("Error: API token is required. Please provide it using -t option, PENIFY_API_TOKEN environment variable, or log in first.")
            sys.exit(1)
        install_git_hook(args.location, token)
    elif args.subcommand == "uninstall-hook":
        uninstall_git_hook(args.location)
    elif args.subcommand == "doc-gen":
        if not token:
            print("Error: API token is required. Please provide it using -t option, PENIFY_API_TOKEN environment variable, or log in first.")
            sys.exit(1)
        generate_doc(token, args.file_path, args.complete_folder_path, args.git_folder_path)
    elif args.subcommand == "commit":
        if not token:
            print("Error: API token is required. Please provide it using -t option, PENIFY_API_TOKEN environment variable, or log in first.")
            sys.exit(1)
        
        open_terminal = args.terminal.lower() == "true"
        
        # Get LLM configuration - first from command line args, then from config file
        llm_model = args.llm_model
        llm_api_base = args.llm_api_base
        llm_api_key = args.llm_api_key
        
        if not llm_model:
            # Try to get from config
            llm_config = get_llm_config()
            llm_model = llm_config.get('model')
            llm_api_base = llm_config.get('api_base') if not llm_api_base else llm_api_base
            llm_api_key = llm_config.get('api_key') if not llm_api_key else llm_api_key
        
        # Get JIRA configuration - first from command line args, then from config file
        jira_url = args.jira_url
        jira_user = args.jira_user
        jira_api_token = args.jira_api_token
        
        if not jira_url or not jira_user or not jira_api_token:
            # Try to get from config
            jira_config = get_jira_config()
            jira_url = jira_url or jira_config.get('url')
            jira_user = jira_user or jira_config.get('username')
            jira_api_token = jira_api_token or jira_config.get('api_token')
        
        commit_code(args.git_folder_path, token, args.message, open_terminal,
                   llm_model, llm_api_base, llm_api_key,
                   jira_url, jira_user, jira_api_token)
    
    elif args.subcommand == "config-llm":
        # Save LLM configuration
        save_llm_config(args.model, args.api_base, args.api_key)
        print(f"LLM configuration set: Model={args.model}, API Base={args.api_base or 'default'}")
    
    elif args.subcommand == "config-jira":
        # Save JIRA configuration
        save_jira_config(args.url, args.username, args.api_token)
        print(f"JIRA configuration set: URL={args.url}, Username={args.username}")
        
        # Verify connection if requested
        if args.verify:
            if JiraClient:
                jira_client = JiraClient(
                    jira_url=args.url,
                    jira_user=args.username,
                    jira_api_token=args.api_token
                )
                if jira_client.is_connected():
                    print("JIRA connection verified successfully!")
                else:
                    print("Failed to connect to JIRA. Please check your credentials.")
            else:
                print("JIRA package not installed. Cannot verify connection.")
    
    elif args.subcommand == "login":
        login()
    else:
        parser.print_help()
        sys.exit(1)

if __name__ == "__main__":
    main()
